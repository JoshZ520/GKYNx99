// UI Components - themes, preferences, and front page functionality
// This module handles all user interface components and interactions

// === COLOR THEME SYSTEM ===

// SVG colors are now handled by simple CSS classes (light-theme/dark-theme)
// No complex color conversion functions needed
// Function to apply color scheme to any page
function applyColorScheme(colorScheme) {
    const root = document.documentElement;
    
    // Determine if this is a dark theme based on background color
    const isDarkTheme = colorScheme.textColor === '#ffffff' || isColorDark(colorScheme.background);
    
    // Add or remove dark theme class on body
    if (isDarkTheme) {
        document.body.classList.add('dark-theme');
        document.body.classList.remove('light-theme');
    } else {
        document.body.classList.add('light-theme');
        document.body.classList.remove('dark-theme');
    }
    
    // Set CSS custom properties using the new variable names
    if (isDarkTheme) {
        root.style.setProperty('--background-dark', colorScheme.background);
        root.style.setProperty('--background-light', colorScheme.headerBackground);
        root.style.setProperty('--accent-dark', colorScheme.headerBorder);
        root.style.setProperty('--accent-light', colorScheme.accent);
        root.style.setProperty('--text-light', colorScheme.textColor);
        root.style.setProperty('--text-dark', colorScheme.headerTextColor);
        root.style.setProperty('--dark', colorScheme.background);
        root.style.setProperty('--light', colorScheme.headerBackground);
    } else {
        root.style.setProperty('--background-light', colorScheme.background);
        root.style.setProperty('--background-dark', colorScheme.headerBackground);
        root.style.setProperty('--accent-light', colorScheme.accent);
        root.style.setProperty('--accent-dark', colorScheme.headerBorder);
        root.style.setProperty('--text-dark', colorScheme.textColor);
        root.style.setProperty('--text-light', colorScheme.headerTextColor);
        root.style.setProperty('--light', colorScheme.background);
        root.style.setProperty('--dark', colorScheme.textColor);
    }
    
    // SVG colors are now handled by CSS classes (light-theme/dark-theme)
    // No need to set SVG filter variables anymore
    
    // Apply colors directly to elements for immediate effect
    document.body.style.backgroundColor = colorScheme.background;
    document.body.style.color = colorScheme.textColor || '#333333';
    
    const header = document.querySelector('header');
    if (header) {
        header.style.backgroundColor = colorScheme.headerBackground;
        header.style.borderColor = colorScheme.headerBorder;
        header.style.color = colorScheme.textColor || '#333333';
    }
    
    // Update all headings
    const headings = document.querySelectorAll('h1, h2, h3, h4, h5, h6');
    headings.forEach(heading => {
        heading.style.color = colorScheme.headerTextColor || '#333333';
    });
    
    // Update all paragraphs and text elements
    const textElements = document.querySelectorAll('p, label, .topic, .preference-label');
    textElements.forEach(element => {
        element.style.color = colorScheme.textColor || '#333333';
    });
    
    const submitBtn = document.querySelector('.submit');
    if (submitBtn) {
        submitBtn.style.backgroundColor = colorScheme.primaryButton;
        submitBtn.style.color = colorScheme.headerTextColor || '#ffffff';
    }
    
    const finBtn = document.querySelector('.fin');
    if (finBtn) {
        finBtn.style.backgroundColor = colorScheme.secondaryButton;
        finBtn.style.color = colorScheme.headerTextColor || '#ffffff';
    }
    
    const startBtn = document.querySelector('.start-btn');
    if (startBtn) {
        startBtn.style.backgroundColor = colorScheme.secondaryButton;
        startBtn.style.color = colorScheme.headerTextColor || '#ffffff';
    }
    
    const footer = document.querySelector('footer');
    if (footer) {
        footer.style.backgroundColor = colorScheme.accent;
        footer.style.color = colorScheme.headerTextColor || '#ffffff';
    }
    
    // Update switch button and dropdown button colors using dedicated SVG colors
    const switchBtn = document.querySelector('.switch_button');
    if (switchBtn) {
        switchBtn.style.backgroundColor = colorScheme.background;
        // Use dedicated SVG color from color scheme
        switchBtn.style.color = colorScheme.svgColor || colorScheme.textColor;
    }
    
    const openPageBtn = document.querySelector('#open_page');
    if (openPageBtn) {
        // Use dedicated SVG color from color scheme
        openPageBtn.style.color = colorScheme.svgColor || colorScheme.textColor;
    }
}

// Helper function to determine if a color is dark
function isColorDark(color) {
    // Convert hex color to RGB
    const hex = color.replace('#', '');
    const r = parseInt(hex.substr(0, 2), 16);
    const g = parseInt(hex.substr(2, 2), 16);
    const b = parseInt(hex.substr(4, 2), 16);
    
    // Calculate luminance using the relative luminance formula
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    
    // Return true if luminance is less than 0.5 (dark color)
    return luminance < 0.5;
}

// Function to load and apply color scheme from the currently selected topic
function loadTopicColorScheme() {
    const currentTopic = localStorage.getItem('currentTopic') || 'default';
    
    // Load color schemes and topic index to get color scheme for current topic
    Promise.all([
        fetch('files/color-schemes.json').then(res => res.json()),
        fetch('files/topics/index.json').then(res => res.json())
    ])
    .then(([colorSchemes, topicsIndex]) => {
        const topicInfo = topicsIndex[currentTopic] || topicsIndex['default'];
        if (topicInfo && topicInfo.colorScheme) {
            const colorScheme = colorSchemes[topicInfo.colorScheme] || colorSchemes['light'] || {};
            applyColorScheme(colorScheme);
        }
    })
    .catch(err => {
        console.warn('Could not load color scheme:', err);
    });
}

// === PREFERENCE SYSTEM ===
// Function to display question options
function displayQuestionOptions(question) {
    // Show preference UI (all questions now have option1 and option2)
    const preferenceContainer = document.getElementById('preferenceContainer');
    
    if (preferenceContainer) {
        preferenceContainer.style.display = 'block';
    }
        
        // Set up image containers for contributors to add images
        const option1Image = document.getElementById('option1Image');
        const option2Image = document.getElementById('option2Image');
        
        // Add data attributes for image loading (contributors can use these)
        if (option1Image) {
            option1Image.setAttribute('data-option', question.option1.toLowerCase().replace(/\s+/g, '-'));
        }
        if (option2Image) {
            option2Image.setAttribute('data-option', question.option2.toLowerCase().replace(/\s+/g, '-'));
        }
        
        // Set the text labels above the images
        const option1Label = document.getElementById('option1Label');
        const option2Label = document.getElementById('option2Label');
        
        if (option1Label) {
            option1Label.textContent = question.option1;
        }
        if (option2Label) {
            option2Label.textContent = question.option2;
        }
        
        // Set up click handlers for preferences
        setupPreferenceClickHandlers(question);
}



// Function to set up preference click handlers
function setupPreferenceClickHandlers(question) {
    const option1Elem = document.getElementById('option1');
    const option2Elem = document.getElementById('option2');
    
    // Remove any existing listeners
    const option1Clone = option1Elem?.cloneNode(true);
    const option2Clone = option2Elem?.cloneNode(true);
    
    if (option1Elem && option1Clone) {
        option1Elem.parentNode.replaceChild(option1Clone, option1Elem);
        option1Clone.addEventListener('click', () => selectPreference(question.option1));
    }
    
    if (option2Elem && option2Clone) {
        option2Elem.parentNode.replaceChild(option2Clone, option2Elem);
        option2Clone.addEventListener('click', () => selectPreference(question.option2));
    }
}

// Function to handle preference selection
function selectPreference(choice) {
    // Visual feedback - highlight selected option
    const option1 = document.getElementById('option1');
    const option2 = document.getElementById('option2');
    
    if (option1) option1.classList.remove('selected');
    if (option2) option2.classList.remove('selected');
    
    // Determine which option to highlight based on the choice
    // We need to get the current question to match choice to option
    const currentIndex = parseInt(document.getElementById('question')?.getAttribute('data-index')) || 0;
    const currentQuestion = appQuestions[currentIndex];
    
    if (currentQuestion && currentQuestion.option1 && currentQuestion.option2) {
        if (choice === currentQuestion.option1 && option1) {
            option1.classList.add('selected');
        } else if (choice === currentQuestion.option2 && option2) {
            option2.classList.add('selected');
        }
    }
    
    // Store the choice in both the hidden preference field and the answer field for submission
    const selectedPreferenceField = document.getElementById('selectedPreference');
    const answerElem = document.getElementById('answer');
    
    if (selectedPreferenceField) {
        selectedPreferenceField.value = choice;
    }
    if (answerElem) {
        answerElem.value = choice;
    }

}

// === COLOR SCHEME LOADING ===
// Load color scheme for all pages
window.addEventListener('DOMContentLoaded', function () {
    // Add default light theme class if no theme is set
    if (!document.body.classList.contains('light-theme') && !document.body.classList.contains('dark-theme')) {
        document.body.classList.add('light-theme');
    }
    
    // Load the current topic's color scheme if stored
    loadTopicColorScheme();
});

// === TOPIC SELECTION SYSTEM ===
// Topic selection system variables
let availableTopics = [];

function initializeTopicSelection() {
    // Load topics from JSON
    fetch('files/topics/index.json')
        .then(res => res.json())
        .then(topicsIndex => {
            // Convert to array, excluding 'default'
            availableTopics = Object.keys(topicsIndex)
                .filter(key => key !== 'default')
                .map(key => ({
                    value: key,
                    name: key.charAt(0).toUpperCase() + key.slice(1)
                }));
            
            renderTopicGrid();
        })
        .catch(err => {
            console.warn('Could not load topics:', err);
        });
    
    // Set up button listeners
    document.getElementById('startButton')?.addEventListener('click', () => setTopic('default'));
    document.getElementById('randomButton')?.addEventListener('click', () => pickRandomTopic());
    document.getElementById('topicsToggle')?.addEventListener('click', toggleTopicsPanel);
}

function renderTopicGrid() {
    const grid = document.getElementById('topicsGrid');
    if (!grid) return;
    
    // Display all available topics in a 2x3 grid layout
    grid.innerHTML = availableTopics.map(topic => `
        <label class="topic-option">
            <input type="radio" name="topic" value="${topic.value}">
            <span>${topic.name}</span>
        </label>
    `).join('');
    
    // Add event listeners
    grid.querySelectorAll('input[name="topic"]').forEach(radio => {
        radio.addEventListener('change', (e) => {
            setTopic(e.target.value);
        });
    });
}



function toggleTopicsPanel() {
    const panel = document.getElementById('topicsPanel');
    const toggle = document.getElementById('topicsToggle');
    
    if (panel.style.display === 'none') {
        panel.style.display = 'block';
        toggle.textContent = 'Topics ▲';
    } else {
        panel.style.display = 'none';
        toggle.textContent = 'Topics ▼';
    }
}



// === FRONT PAGE FUNCTIONALITY ===
// Handle player count selection and storage
function handleFrontPageFunctionality() {
    const select = document.getElementById('player_count');
    if (!select) return; // Not on front page
    
    // When the selection changes, store the value as an integer in sessionStorage
    select.addEventListener('change', function (e) {
        const rawValue = e.target.value;
        const val = parseInt(rawValue, 10);
        if (!Number.isNaN(val) && val > 0) {
            sessionStorage.setItem('playerCount', String(val));
        } else {
            sessionStorage.removeItem('playerCount');
        }
    });

    // If the user navigates to this page and then back, pre-select the stored value
    const stored = parseInt(sessionStorage.getItem('playerCount'), 10);
    if (!Number.isNaN(stored) && stored > 0) {
        const opt = Array.from(select.options).find(o => parseInt(o.value, 10) === stored);
        if (opt) select.value = String(stored);
    }
}

// Function to load and display the front page instruction
function loadFrontPageInstruction() {
    const instructionElement = document.getElementById('front-instruction');
    if (!instructionElement) return; // Not on front page
    
    fetch('files/topics/default.json')
        .then(res => {
            if (!res.ok) throw new Error('Failed to load default.json');
            return res.json();
        })
        .then(data => {
            if (data.questions && data.questions.length > 0) {
                // Use the first question as the front page instruction
                const frontInstruction = data.questions[0];
                instructionElement.textContent = frontInstruction;
            }
        })
        .catch(err => {
            console.warn('Could not load front page instruction:', err);
        });
}

// === PLAYER SETUP SYSTEM ===
function initializePlayerSetup() {
    const playerCountSelect = document.getElementById('player_count');
    const playerSetupSection = document.getElementById('playerSetupSection');
    const playerNamesContainer = document.getElementById('playerNamesContainer');
    const startButton = document.getElementById('start-game-btn');
    
    if (!playerCountSelect || !playerSetupSection || !playerNamesContainer) return;
    
    playerCountSelect.addEventListener('change', function(e) {
        const playerCount = parseInt(e.target.value);
        
        if (playerCount && playerCount > 0) {
            showPlayerSetup(playerCount);
            updateStartButtonState();
        } else {
            hidePlayerSetup();
        }
    });
    
    // Check start button state when player names change
    if (playerNamesContainer) {
        playerNamesContainer.addEventListener('input', updateStartButtonState);
    }
}

function showPlayerSetup(playerCount) {
    const playerSetupSection = document.getElementById('playerSetupSection');
    const playerNamesContainer = document.getElementById('playerNamesContainer');
    
    if (!playerSetupSection || !playerNamesContainer) return;
    
    // Clear existing inputs
    playerNamesContainer.innerHTML = '';
    
    // Create player name inputs
    for (let i = 1; i <= playerCount; i++) {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'player-input-group';
        
        inputGroup.innerHTML = `
            <div class="player-number">${i}</div>
            <input 
                type="text" 
                class="player-name-input" 
                placeholder="Enter player ${i} name"
                data-player="${i}"
                required
            >
        `;
        
        playerNamesContainer.appendChild(inputGroup);
    }
    
    // Show the section
    playerSetupSection.style.display = 'block';
    
    // Focus on first input
    const firstInput = playerNamesContainer.querySelector('.player-name-input');
    if (firstInput) {
        setTimeout(() => firstInput.focus(), 100);
    }
}

function hidePlayerSetup() {
    const playerSetupSection = document.getElementById('playerSetupSection');
    if (playerSetupSection) {
        playerSetupSection.style.display = 'none';
    }
}

function updateStartButtonState() {
    const playerCountSelect = document.getElementById('player_count');
    const playerNamesContainer = document.getElementById('playerNamesContainer');
    const startButton = document.getElementById('start-game-btn');
    
    if (!playerCountSelect || !startButton) return;
    
    const selectedCount = parseInt(playerCountSelect.value);
    
    if (!selectedCount) {
        // No player count selected
        startButton.style.opacity = '0.5';
        startButton.style.pointerEvents = 'none';
        return;
    }
    
    if (selectedCount > 1 && playerNamesContainer) {
        // Check if all player names are filled
        const nameInputs = playerNamesContainer.querySelectorAll('.player-name-input');
        const allNamesFilled = Array.from(nameInputs).every(input => input.value.trim() !== '');
        
        if (allNamesFilled) {
            // Save player names to sessionStorage
            const playerNames = Array.from(nameInputs).map(input => input.value.trim());
            sessionStorage.setItem('playerNames', JSON.stringify(playerNames));
            
            startButton.style.opacity = '1';
            startButton.style.pointerEvents = 'auto';
        } else {
            startButton.style.opacity = '0.5';
            startButton.style.pointerEvents = 'none';
        }
    } else {
        // Single player or no setup needed
        startButton.style.opacity = '1';
        startButton.style.pointerEvents = 'auto';
    }
    
    // Add click handler if not already added
    if (!startButton.hasAttribute('data-handler-added')) {
        startButton.addEventListener('click', handleStartGame);
        startButton.setAttribute('data-handler-added', 'true');
    }
}

function handleStartGame(e) {
    e.preventDefault();
    
    const playerCountSelect = document.getElementById('player_count');
    const selectedCount = parseInt(playerCountSelect.value);
    
    if (!selectedCount) {
        alert('Please select the number of players first.');
        return;
    }
    
    // Store player count in sessionStorage
    sessionStorage.setItem('playerCount', selectedCount.toString());
    
    if (selectedCount > 1) {
        const playerNamesContainer = document.getElementById('playerNamesContainer');
        const nameInputs = playerNamesContainer.querySelectorAll('.player-name-input');
        const allNamesFilled = Array.from(nameInputs).every(input => input.value.trim() !== '');
        
        if (!allNamesFilled) {
            alert('Please enter names for all players.');
            return;
        }
        
        // Player names are already saved by updateStartButtonState
    }
    
    // Navigate to game page
    window.location.href = 'game.html';
}